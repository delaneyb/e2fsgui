<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<title>e2fsgui</title>
	<script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
	<!-- Day.js for nicer date formatting -->
	<script src="https://unpkg.com/dayjs@1.11.10/dayjs.min.js"></script>
	<script src="https://unpkg.com/dayjs@1.11.10/plugin/relativeTime.js"></script>
	<script src="https://unpkg.com/dayjs@1.11.10/plugin/utc.js"></script>
	<script>dayjs.extend(window.dayjs_plugin_relativeTime)</script>
	<script>dayjs.extend(window.dayjs_plugin_utc)</script>
	<style>
		#app {
			margin: 0;
			display: flex;
			width: 100vw;
			height: 100vh;

			flex-direction: column;
			font: 14px/1.4 -apple-system, Segoe UI, Roboto, sans-serif;
			color: #222;
		}

		.container {
			width: 100%;
			height: 100%;
			display: flex;
			overflow: hidden;
		}

		#sidebar {
			min-width: 220px;
			border-right: 1px solid #ddd;
			background: #fafafa;
		}

		#sidebar div {
			padding: 10px 12px;
			cursor: pointer;
			border-bottom: 1px solid #eee;
		}

		#sidebar div:hover {
			background: #f0f0f0;
		}

		#sidebar .active {
			background: #dbeaff;
			font-weight: 600;
		}

		#main {
			flex: 1;
			overflow: hidden;
			display: flex;
			flex-direction: column;
			position: relative;
		}

		#main.drag-over {
			background-color: rgba(0,0,0,0.05);
		}

		.drag-over-overlay {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: rgba(0,0,0,0.1);
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			color: #333;
			z-index: 5;
			pointer-events: none;
		}

		.crumbs-header {
			padding: 8px 12px;
			border-bottom: 1px solid #ddd;
			background: #f7f7f7;
			
			display: flex;
			align-items: center;
			font-size: 13px;
			flex-wrap: wrap;
		}

		.crumb-path {
			display: flex;
			align-items: center;
			gap: 6px;
		}

		.crumb-path > a {
			text-decoration: none;
			color: #777;
			font-weight: normal;
			cursor: pointer;
			padding: 0 2px;
		}

		.crumb-path > a:hover {
			color: #222;
		}

		.crumb-path > a.current {
			color: #333;
			font-weight: 500;
			cursor: default;
		}
		

		table {
			border-collapse: separate;
			border-spacing: 0;
			width: 100%;
		}

		td,
		th {
			padding: 6px 8px;
			text-align: left;
		}

		tr:hover {
			background: #f9f9f9;
		}

		/* Modern button style */
		button {
			padding: 6px 12px;
			border: none;
			border-radius: 4px;
			background-color: #f2f2f2;
			color: #333;
			cursor: pointer;
			transition: background-color 0.2s;
		}
		button:hover:not(:disabled) {
			background-color: #e0e0e0;
		}
		button:disabled {
			opacity: 0.6;
			cursor: not-allowed;
		}

		/* Actions row buttons */
		.actions-row button {
			margin: 0;
			white-space: nowrap;
			flex-shrink: 0;
		}

		/* Icon-only action buttons - simplified to match default button sizing */
		.action-icon-only {
			display: flex;
			align-items: center;
			justify-content: center;
			border: none;
			border-radius: 4px;
			background-color: #f2f2f2;
			cursor: pointer;
			transition: background-color 0.2s;
		}

		.status-bar {
			padding: 8px 12px;
			background: #f0f0f0;
			border-top: 1px solid #ddd;
			font-size: 13px;
			color: #666;
			white-space: pre-wrap;
		}

		.error {
			color: #d32f2f;
			background: #ffebee;
			padding: 8px 12px;
			white-space: pre-wrap;
			overflow-wrap: break-word;
		}

		.loading-overlay {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(255, 255, 255, 0.7);
			display: flex;
			align-items: center;
			justify-content: center;
			z-index: 10;
		}

		.loader {
			border: 3px solid #f3f3f3;
			border-top: 3px solid #3498db;
			border-radius: 50%;
			width: 20px;
			height: 20px;
			animation: spin 1s linear infinite;
			margin-right: 10px;
		}

		@keyframes spin {
			0% {
				transform: rotate(0deg);
			}

			100% {
				transform: rotate(360deg);
			}
		}

		[v-cloak] {
			display: none;
		}

		th:first-child,
		td:first-child {
			width: 32px;
			text-align: center;
		}

		th:nth-child(2),
		td:nth-child(2) {
			min-width: 150px;
		}

		th:nth-child(3),
		td:nth-child(3) {
			min-width: 80px;
		}

		th:nth-child(4),
		td:nth-child(4) {
			min-width: 70px;
			white-space: nowrap;
		}

		th:nth-child(5),
		td:nth-child(5) {
			min-width: 50px;
			text-align: right;
		}

		th:nth-child(6),
		td:nth-child(6) {
			min-width: 50px;
			text-align: right;
		}

		th:nth-child(7),
		td:nth-child(7) {
			min-width: 230px;
			text-align: left;
		}

		button:first-child {
			margin-left: 0;
		}

		.actions-row {
			display: flex;
			gap: 8px;
			align-items: center;
		}

		.action-icon-only[style*="color:red"] {
			color: #d32f2f;
		}

		/* Apply sticky positioning to thead */
		table thead {
			position: sticky;
			top: 0;
			background: #fafafa;
			z-index: 1;
		}

		table thead th {
			background: #fafafa;
			border-bottom: 1px solid #ddd;
		}

		/* New style for the scroll container */
		.table-scroll-container {
			flex: 1;
			width: 100%;
			height: 100%;
			overflow: auto;
			position: relative;
		}

		tbody tr td {
			border-bottom: 1px solid whitesmoke;
		}
	</style>
</head>

<body id="app" v-cloak>
	<div class="container">
		<div id="sidebar">
			<div v-for="d in disks" :key="d.id" :class="{ active: currentDev === d.id }" @click="openDisk(d)">{{ d.name }} ({{ d.size }})</div>
		</div>
		<div id="main"
			:class="{ 'drag-over': dragOver }"
			@dragenter.prevent="onDragEnter"
			@dragover.prevent="onDragOver"
			@dragleave.prevent="onDragLeave"
			@drop.prevent="onDrop"
		>
			<div v-if="dragOver" class="drag-over-overlay">Drop files here to upload</div>
			<div class="crumbs-header">
				<div class="crumb-path">
					<template v-for="(seg, idx) in crumbSegments" :key="idx">
						<i v-if="idx > 0" class="fa-solid fa-angle-right crumb-sep"></i>
						<a href="#" @click.prevent="seg.path !== currentPath && openDir(seg.path)" :class="['crumb-segment', { current: seg.path === currentPath }]" >{{ seg.name }}</a>
					</template>
				</div>
			
				<button @click="createNewDirectory" style="margin-left: 15px;" title="Create New Folder" class="action-icon-only"><i class="fa-solid fa-folder-plus"></i></button>
			</div>
			<div v-if="error" class="error">{{ error }}</div>
			<div class="table-scroll-container">
				<table v-if="currentDev">
					<thead>
						<tr>
							<th></th>
							<th @click="sortBy('name')" style="cursor:pointer">
								Name <span v-if="sortKey==='name'"><i :class="sortAsc ? 'fa-solid fa-caret-up' : 'fa-solid fa-caret-down'"></i></span>
							</th>
							<th @click="sortBy('size')" style="cursor:pointer">
								Size <span v-if="sortKey==='size'"><i :class="sortAsc ? 'fa-solid fa-caret-up' : 'fa-solid fa-caret-down'"></i></span>
							</th>
							<th @click="sortBy('mode')" style="cursor:pointer">
								Mode <span v-if="sortKey==='mode'"><i :class="sortAsc ? 'fa-solid fa-caret-up' : 'fa-solid fa-caret-down'"></i></span>
							</th>
							<th @click="sortBy('uid')" style="cursor:pointer">
								UID <span v-if="sortKey==='uid'"><i :class="sortAsc ? 'fa-solid fa-caret-up' : 'fa-solid fa-caret-down'"></i></span>
							</th>
							<th @click="sortBy('gid')" style="cursor:pointer">
								GID <span v-if="sortKey==='gid'"><i :class="sortAsc ? 'fa-solid fa-caret-up' : 'fa-solid fa-caret-down'"></i></span>
							</th>
							<th @click="sortBy('mtime')" style="cursor:pointer">
								Modified <span v-if="sortKey==='mtime'"><i :class="sortAsc ? 'fa-solid fa-caret-up' : 'fa-solid fa-caret-down'"></i></span>
							</th>
							<th style="text-align:left;">
								Actions
								<span style="float:right; font-weight:normal; font-size:12px; margin-left:10px;">
									<label style="cursor:pointer; user-select:none;">
										<input type="checkbox" v-model="separateFolders" style="vertical-align:middle; margin-right:3px;" />
										Folders first
									</label>
								</span>
							</th>
						</tr>
					</thead>
					<tbody>
						<tr v-if="currentPath!=='/'" @click="upOne" style="cursor:pointer">
							<td><i class="fas fa-arrow-up"></i></td>
							<td colspan="3">..</td>
							<td colspan="3"></td>
							<td colspan="2"></td>
						</tr>
						<tr v-for="r in sortedRows" :key="r.name" @click="r.isDir ? openDir(r.name) : null" :style="r.isDir ? 'cursor:pointer' : ''">
							<td>
								<i v-if="r.fileType === 'directory'" class="fa-solid fa-folder"></i>
								<i v-else-if="r.fileType === 'symlink'" class="fa-solid fa-link"></i>
								<i v-else-if="r.fileType === 'block'" class="fa-solid fa-hard-drive"></i>
								<i v-else-if="r.fileType === 'character'" class="fa-solid fa-terminal"></i>
								<i v-else-if="r.fileType === 'fifo'" class="fa-solid fa-pipe"></i>
								<i v-else-if="r.fileType === 'socket'" class="fa-solid fa-plug"></i>
								<i v-else class="fa-solid fa-file"></i>
							</td>
							<td>{{ r.name }}</td>
							<td>{{ r.isDir ? '' : r.size }}</td>
							<td><span style="font-family: monospace;">{{ formatMode(r.mode) }}</span></td>
							<td style="text-align: right;">{{ r.uid }}</td>
							<td style="text-align: right;">{{ r.gid }}</td>
							<td>{{ formatModified(r.mtime) }}</td>
							<td>
								<div class="actions-row">
									<button v-if="!r.isDir && r.fileType === 'regular'" @click.stop="viewFile(r)" title="View File Content"><i class="fa-solid fa-eye"></i> View</button>
									<button v-if="r.fileType === 'directory'" @click.stop="saveDirectory(r)" :disabled="!!r.saveStatus && r.saveStatus !== '✔ Saved'"><i class="fa-solid fa-save"></i> {{ r.saveStatus || (r.saved ? 'Saved' : 'Save') }}</button>
									<button v-else @click.stop="saveFile(r)" :disabled="!!r.saveStatus && r.saveStatus !== '✔ Saved'"><i class="fa-solid fa-save"></i> {{ r.saveStatus || (r.saved ? 'Saved' : 'Save') }}</button>
									<button @click.stop="showInfo(r)" title="Show Info" class="action-icon-only"><i class="fa-solid fa-circle-info"></i></button>
									<button @click.stop="deleteSelectedItem(r)" title="Delete Item" class="action-icon-only" style="color:red;"><i class="fa-solid fa-trash"></i></button>
								</div>
							</td>
						</tr>
						<tr v-if="rows.length === 0 && !loading && !error">
							<td colspan="7" style="text-align:center;padding:20px;color:#666">
								This directory is empty
							</td>
						</tr>
					</tbody>
				</table>
				<div v-if="currentDev" style="text-align:center; color:#888; font-size:13px; margin: 18px;">
					<i class="fa-solid fa-file-import" style="font-size:15px; margin-right:6px;"></i> Drag and drop files or folders to upload
				</div>
			</div>
			<!-- Close scroll container -->
		</div>
	</div>

	<div class="status-bar">{{ status }}</div>

	<div v-if="loading" class="loading-overlay">
		<div class="loader"></div>
		<div>{{ status }}</div>
	</div>

	<!-- Info Modal -->
	<div v-if="showInfoModal" class="loading-overlay" @click.self="closeInfoModal" style="background: rgba(0,0,0,0.5); z-index: 20;">
		<div style="background: white; padding: 20px; border-radius: 5px; max-width: 80%; max-height: 80%; display: flex; flex-direction: column; overflow: hidden;">
			<h3>Info: {{ currentItemName }}</h3>
			<pre style="flex: 1; overflow: auto; white-space: pre-wrap; word-wrap: break-word; background: #f8f8f8; border: 1px solid #eee; padding: 10px; margin: 10px 0; min-height: 0;">{{ infoContent }}</pre>
			<button @click="closeInfoModal" style="align-self: flex-end; margin-top: 10px;">Close</button>
		</div>
	</div>

	<!-- View File Modal -->
	<div v-if="showViewModal" class="loading-overlay" @click.self="closeViewModal" style="background: rgba(0,0,0,0.5); z-index: 20;">
		<div style="background: white; padding: 20px; border-radius: 5px; max-width: 90%; max-height: 90%; display: flex; flex-direction: column; overflow: hidden;">
			<h3>View: {{ currentItemName }}</h3>
			<pre style="flex: 1; overflow: auto; white-space: pre-wrap; word-wrap: break-word; background: #f8f8f8; border: 1px solid #eee; padding: 10px; min-height: 0;">{{ viewContent }}</pre>
			<button @click="closeViewModal" style="align-self: flex-end; margin-top: 10px;">Close</button>
		</div>
	</div>

	<!-- New Directory Modal -->
	<div v-if="newDirModalVisible" class="loading-overlay" style="background: rgba(0,0,0,0.5); z-index: 30;" @click.self="cancelNewDirectory">
		<div style="background: white; padding: 20px; border-radius: 5px; max-width: 90vw; min-width: 260px; display: flex; flex-direction: column; align-items: stretch;">
			<h3 style="margin-top:0">Create New Directory</h3>
			<input v-model="newDirName" @keyup.enter="confirmNewDirectory" placeholder="Directory name" style="font-size: 16px; padding: 6px 8px; margin-bottom: 8px; border: 1px solid #ccc; border-radius: 4px;" autofocus />
			<div v-if="newDirModalError" style="color:#d32f2f; font-size:13px; margin-bottom:8px;">{{ newDirModalError }}</div>
			<div style="display:flex; gap:10px; justify-content:flex-end;">
				<button @click="cancelNewDirectory">Cancel</button>
				<button @click="confirmNewDirectory" :disabled="!newDirName.trim()">Create</button>
			</div>
		</div>
	</div>

	<!-- Internet Required Modal -->
	<div v-if="false" class="loading-overlay" style="background: rgba(0,0,0,0.5); z-index: 10000; text-align: center;">
		<div style="background: white; padding: 20px; margin: 20px; border-radius: 5px; min-width: 250px; max-width: 700px; display: flex; flex-direction: column; place-content: center;">
			<h3 style="margin-top:0">Internet Connection Required</h3>
			<p>This application depends on CDN served libraries such as Vue.JS and DayJS, without which the interface cannot render (I haven't been bothered putting together a bundling step, sorry 😜).</p>
			<p>Please ensure internet is connected and/or press ⌘R</p>
		</div>
	</div>
</body>

<script>
	const { execSync, execFile } = require('child_process')
	const path = require('path')
	const os = require('os')
	const fs = require('fs')
	const debugUtils = require('./debugfs-utils')

	// Find Homebrew installation path and e2fsprogs binaries
	function findHomebrewPath() {
		try {
			// Try to get the Homebrew prefix
			const brewPrefix = execSync('brew --prefix').toString().trim()
			return brewPrefix
		} catch (e) {
			console.error("Error finding Homebrew:", e)
			// Fallbacks for common Homebrew locations
			if (fs.existsSync('/opt/homebrew')) {
				return '/opt/homebrew' // M1/M2 Mac location
			} else if (fs.existsSync('/usr/local/Homebrew')) {
				return '/usr/local' // Intel Mac location
			}
			return null
		}
	}

	// Get full path to a Homebrew-installed program
	function getBrewBinPath(program) {
		const brewPath = findHomebrewPath()
		if (!brewPath) return null

		// Check e2fsprogs paths - binaries might be in bin/ or sbin/
		const e2fsprogsPrefix = path.join(brewPath, 'opt', 'e2fsprogs')

		const possiblePaths = [
			path.join(e2fsprogsPrefix, 'sbin', program),
			path.join(e2fsprogsPrefix, 'bin', program),
			path.join(brewPath, 'sbin', program),
			path.join(brewPath, 'bin', program),
		]

		for (const binPath of possiblePaths) {
			if (fs.existsSync(binPath)) {
				return binPath
			}
		}

		return null
	}

	function plistXmlToJson(xmlStr) {
		const buf = execSync('plutil -convert json -o - -', { input: xmlStr })
		return JSON.parse(buf.toString())
	}

	function listLinuxDisks() {
		const xml = execSync('diskutil list -plist').toString()
		const data = plistXmlToJson(xml)
		if (!data.AllDisksAndPartitions) return []
		return data.AllDisksAndPartitions.flatMap(d => {
			// Make sure this disk has partitions
			if (!d.Partitions) return []

			// Filter and map partitions with Linux content
			return d.Partitions
				.filter(p => /Linux/i.test(p.Content || ''))
				.map(p => ({
					id: p.DeviceIdentifier,
					name: p.VolumeName || p.DeviceIdentifier,
					size: p.Size ? formatSize(p.Size) : 'Unknown',
					sizeBytes: p.Size || 0
				}))
		})
	}

	// Helper function to format bytes to readable size
	function formatSize(bytes) {
		if (bytes === 0) return '0 B'
		const sizes = ['B', 'KB', 'MB', 'GB', 'TB']
		const i = Math.floor(Math.log(bytes) / Math.log(1024))
		return (bytes / Math.pow(1024, i)).toFixed(1) + ' ' + sizes[i]
	}

	function listDir(device, dirPath) {
		// Use long listing to include time info in one call
		return debugUtils.runDebugFs(device, `ls -l ${dirPath}`)
			.then(({ stdout }) => {
				const lines = stdout.split('\n').filter(l => l.trim() && !l.startsWith('debugfs'))
				return lines.flatMap(line => {
					const m = line.match(/^\s*(\d+)\s+(\d+)\s+\(\d+\)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d{1,2}-[A-Za-z]{3}-\d{4} \d{1,2}:\d{2})\s+(.+)$/)
					if (!m) return []
					const [ , inode, mode, uid, gid, sizeStr, dateStr, rawName ] = m
					const name = rawName.trim()
					if (name === '.' || name === '..') return []
					const modeNum = parseInt(mode, 8)
					const fileType = getFileType(modeNum)
					const rawSize = parseInt(sizeStr, 10)
					const d = dayjs(dateStr, 'D-MMM-YYYY HH:mm')
					return [{
						name,
						isDir: fileType === 'directory',
						size: rawSize ? formatSize(rawSize) : '',
						inode,
						mode,
						uid,
						gid,
						rawSize,
						fileType,
						mtime: d.isValid() ? d.unix() : null
					}]
				})
			})
	}

	// Helper function to determine file type from mode bits
	function getFileType(modeNum) {
		const type = modeNum & 0o170000;
		switch (type) {
			case 0o040000: return 'directory';
			case 0o100000: return 'regular';
			case 0o120000: return 'symlink';
			case 0o060000: return 'block';
			case 0o020000: return 'character';
			case 0o010000: return 'fifo';
			case 0o140000: return 'socket';
			default: return 'unknown';
		}
	}

	function copyFile(device, srcPath, destDir) {
		return new Promise((resolve, reject) => {
			const dest = path.join(destDir, path.basename(srcPath))
			debugUtils.runDebugFs(device, `dump -p ${srcPath} ${dest}`)
				.then(() => {
					const sudoUid = process.env.SUDO_UID && parseInt(process.env.SUDO_UID, 10)
					const sudoGid = process.env.SUDO_GID && parseInt(process.env.SUDO_GID, 10)
					if (sudoUid && sudoGid && !isNaN(sudoUid) && !isNaN(sudoGid)) {
						try { fs.chownSync(dest, sudoUid, sudoGid) } catch (e) { console.warn(`Failed to chown ${dest}: ${e.message}`) }
					}
					resolve(dest)
				})
				.catch(err => reject(new Error(`Failed to copy file: ${err.message}`)))
		})
	}

	function copyDirectory(device, srcPath, destDir) {
		return debugUtils.runDebugFs(device, `rdump ${srcPath} ${destDir}`)
			.then(() => {
				const sudoUid = process.env.SUDO_UID && parseInt(process.env.SUDO_UID, 10)
				const sudoGid = process.env.SUDO_GID && parseInt(process.env.SUDO_GID, 10)
				if (sudoUid && sudoGid && !isNaN(sudoUid) && !isNaN(sudoGid)) {
					try {
						fs.chownSync(destDir, sudoUid, sudoGid)
						execSync(`find ${JSON.stringify(destDir)} -exec chown ${sudoUid}:${sudoGid} {} +`)
					} catch (e) {
						console.warn(`Failed to recursively chown ${destDir}: ${e.message}`)
					}
				}
				return destDir
			})
			.catch(err => { throw new Error(`Failed to copy directory: ${err.message}`) })
	}

	function getInodeInfo(device, itemPath) {
		return debugUtils.runDebugFs(device, `stat ${itemPath}`)
			.then(({ stdout, stderr }) => (stdout.trim() || stderr.trim()))
	}

	function readFileContent(device, filePath) {
		return debugUtils.runDebugFs(device, `cat ${filePath}`, { maxBuffer: 1024 * 1024 * 5 })
			.then(({ stdout, stderr }) => {
				if (stderr && stderr.includes('Cannot read block') && stdout) {
					console.warn(`readFileContent: Partial read or error for ${filePath}: ${stderr}`)
					return stdout + "\n\n[Warning: Error during read - content might be incomplete or corrupted]"
				}
				return stdout
			})
	}

	function createDirectory(device, newDirPath) {
		return debugUtils.runDebugFs(device, `mkdir ${newDirPath}`, { write: true }).then(() => {})
	}

	function deleteItem(device, itemPath, isDir) {
		const cmd = isDir ? `rmdir ${itemPath}` : `rm ${itemPath}`
		return debugUtils.runDebugFs(device, cmd, { write: true })
			.catch(err => {
				if (err.message && err.message.includes('Directory not empty')) {
					throw new Error(`Directory not empty: ${itemPath}`)
				}
				throw new Error(`Failed to delete ${isDir ? 'directory' : 'file'}: ${err.message}`)
			})
	}

	const { createApp } = Vue
	createApp({
		data() {
			return {
				disks: [],
				currentDev: null,
				currentPath: '/',
				rows: [],
				lastDestDir: path.join(os.homedir(), 'Downloads'),
				loading: true,
				status: 'Looking for Linux partitions...',
				error: null,
				debugfsPath: null,
				e2cpPath: null,
				scanInterval: null,
				sortKey: 'mtime',
				sortAsc: false,
				// New state for modals
				showInfoModal: false,
				infoContent: '',
				showViewModal: false,
				viewContent: '',
				currentItemName: '', // For modal titles
				dragOver: false,
				dragCounter: 0,
				newDirModalVisible: false,
				newDirName: '',
				newDirModalError: '',
				separateFolders: false,
			}
		},
		computed: {
			crumbSegments() {
				if (!this.currentDev) return []
				const parts = this.currentPath.split('/').filter(Boolean)
				const segments = []
				// first segment shows the disk identifier
				segments.push({ name: this.currentDev, path: '/' })
				let accum = '/'
				parts.forEach(part => {
					accum = path.posix.join(accum, part) // Use path.posix.join for reliability
					segments.push({ name: part, path: accum })
				})
				return segments
			},
			sortedRows() {
				const sorted = [...this.rows]
				sorted.sort((a, b) => {
					if (this.separateFolders && a.isDir !== b.isDir) {
						return a.isDir ? -1 : 1
					}
					let result
					if (this.sortKey === 'name') {
						result = a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' })
					} else if (this.sortKey === 'size') {
						result = a.rawSize - b.rawSize
					} else if (this.sortKey === 'mode') {
						result = (a.mode || '').localeCompare(b.mode || '')
					} else if (this.sortKey === 'uid') {
						result = parseInt(a.uid || '0') - parseInt(b.uid || '0')
					} else if (this.sortKey === 'gid') {
						result = parseInt(a.gid || '0') - parseInt(b.gid || '0')
					} else if (this.sortKey === 'mtime') {
						result = (a.mtime || 0) - (b.mtime || 0)
					} else {
						result = 0
					}
					return this.sortAsc ? result : -result
				})
				return sorted
			},
		},
		methods: {
			findTools() {
				this.loading = true
				this.status = "Locating e2fsprogs binaries..."

				this.debugfsPath = debugUtils.getBrewBinPath('debugfs')
				this.e2cpPath = debugUtils.getBrewBinPath('e2cp')

				if (!this.debugfsPath) {
					this.error = `Cannot find 'debugfs'. Please install e2fsprogs with: brew install e2fsprogs`
					this.loading = false
					return false
				}

				this.status = `Found debugfs at ${this.debugfsPath}`
				this.status += "\nReady (running as root)"

				return true
			},
			refreshDisks(showLoading = true) {
				if (showLoading) {
					this.loading = true
				}
				this.error = null

				if (showLoading) {
					this.status = "Looking for Linux partitions..."
				}

				if (!this.findTools()) {
					return
				}

				try {
					this.disks = listLinuxDisks()

					if (this.disks.length === 0) {
						// If no disks found, start auto-rescanning
						this.startAutoRescan()
						// We're still loading (scanning) in this case
						this.loading = true
					} else {
						// If disks found, stop auto-rescanning and hide loading indicator
						this.stopAutoRescan()
						this.status = `Found ${this.disks.length} Linux partition(s). Select one to browse.`
						this.loading = false
						// Auto-select first disk if none selected
						if (!this.currentDev) {
							this.openDisk(this.disks[0])
						}
					}
				} catch (e) {
					this.error = `Error detecting Linux partitions: ${e.message}`
					console.error(e)
					this.loading = false
					this.stopAutoRescan() // Stop scanning on error
				}
			},
			openDisk(d) {
				this.currentDev = d.id
				this.openDir('/')
			},
			async openDir(dir) {
				this.rows = []
				this.loading = true
				this.error = null
				const oldPath = this.currentPath || '/'
				const newPath = dir.startsWith('/') ? dir : (oldPath === '/' ? `/${dir}` : `${oldPath}/${dir}`)
				this.currentPath = newPath
				this.status = `Reading directory ${newPath}...`
				try {
					this.rows = await listDir(this.currentDev, newPath)
					this.status = `Browsing ${this.currentDev}${newPath} - ${this.rows.length} entries`
				} catch (e) {
					this.error = `Failed to list directory: ${e.message}`
					console.error(e)
				} finally {
					this.loading = false
				}
			},
			upOne() {
				if (this.currentPath === '/' || !this.currentPath) return
				const parent = path.posix.dirname(this.currentPath)
				this.openDir(parent)
			},
			async saveFile(row) {
				const originalText = row.saved ? '✔ Saved' : 'Save'
				row.saveStatus = 'Copying...'
				row.error = null // Clear previous error for this item

				try {
					const fullSrcPath = path.posix.join(this.currentPath, row.name)
					const destPath = await copyFile(this.currentDev, fullSrcPath, this.lastDestDir)
					row.saved = true
					row.saveStatus = '✔ Saved'
					this.status = `File saved to ${destPath}`
				} catch (e) {
					row.saveStatus = '❌ Failed'
					row.error = `Copy failed: ${e.message}` // Store error on the row? Or use global error?
					this.error = `Copy failed for ${row.name}: ${e.message}` // Show globally too
					console.error(e)

					// Reset status after 5 seconds
					setTimeout(() => {
						if (row.saveStatus === '❌ Failed') { // Only reset if still failed
							row.saveStatus = originalText
						}
					}, 5000)
				}
			},
			// save an entire directory recursively
			async saveDirectory(row) {
				const originalText = row.saved ? '✔ Saved' : 'Save'
				row.saveStatus = 'Copying...'
				row.error = null

				try {
					const fullSrcPath = path.posix.join(this.currentPath, row.name)
					const destPath = await copyDirectory(this.currentDev, fullSrcPath, this.lastDestDir)
					row.saved = true // Should we mark directory as saved? Maybe less useful.
					row.saveStatus = '✔ Saved'
					this.status = `Directory saved to ${destPath}` // Use actual returned path
				} catch (e) {
					row.saveStatus = '❌ Failed'
					row.error = `Copy failed: ${e.message}`
					this.error = `Copy failed for directory ${row.name}: ${e.message}`
					console.error(e)
					setTimeout(() => {
						if (row.saveStatus === '❌ Failed') {
							row.saveStatus = originalText
						}
					}, 5000)
				}
			},
			startAutoRescan() {
				this.stopAutoRescan() // Ensure no duplicate intervals

				this.status = "Scanning for Linux partitions (plug in drive if needed)..."
				this.loading = true

				// Initial scan immediately
				this.scanDisksInBackground()

				// Start scanning every 2 seconds (1s might be too frequent)
				this.scanInterval = setInterval(this.scanDisksInBackground, 2000)
			},
			scanDisksInBackground() {
				// Don't show loading indicator during background scans unless it's already loading
				// Don't show status updates unless disks are found or an error occurs initially

				try {
					const currentDisks = listLinuxDisks()
					// Check if the list of disks actually changed (simple length check for now)
					// A more robust check would compare disk IDs if needed
					if (currentDisks.length > 0 && this.disks.length === 0) {
						this.disks = currentDisks
						this.stopAutoRescan()
						this.status = `Found ${this.disks.length} Linux partition(s). Select one to browse.`
						this.loading = false // Hide loading indicator now
						// --- Automatically select the first disk ---
						if (this.disks.length > 0) {
							this.openDisk(this.disks[0])
						}
						// -----------------------------------------
					} else if (currentDisks.length === 0 && this.disks.length > 0) {
						// Disks were removed, reset state
						this.disks = []
						this.currentDev = null
						this.currentPath = '/'
						this.rows = []
						this.error = null
						// Restart scanning
						this.startAutoRescan()
					}
					// If list is unchanged (and >0), or still 0, do nothing visually
				} catch (e) {
					// Only show error if it's the *first* scan attempt or if loading is active
					if (this.loading) {
						this.error = `Error during disk scan: ${e.message}`
						console.error("Error during auto-scan:", e)
						this.loading = false // Stop showing loading on error
					} else {
						// Log subsequent errors quietly
						console.warn("Non-critical error during background disk scan:", e.message)
					}
					// Consider stopping scan on persistent errors?
					// this.stopAutoRescan()
				}
			},
			stopAutoRescan() {
				if (this.scanInterval) {
					clearInterval(this.scanInterval)
					this.scanInterval = null
				}
			},
			sortBy(key) {
				if (this.sortKey === key) {
					this.sortAsc = !this.sortAsc
				} else {
					this.sortKey = key
					this.sortAsc = true // Default to ascending when changing column
				}
			},
			// ---- New Methods ----
			async showInfo(item) {
				this.loading = true
				this.status = `Getting info for ${item.name}...`
				this.error = null
				this.currentItemName = item.name
				try {
					const fullPath = path.posix.join(this.currentPath, item.name)
					this.infoContent = await getInodeInfo(this.currentDev, fullPath)
					this.showInfoModal = true
					this.status = `Showing info for ${item.name}`
				} catch (e) {
					this.error = `Failed to get info: ${e.message}`
					console.error(e)
					this.status = `Error getting info for ${item.name}`
				} finally {
					this.loading = false
				}
			},
			async viewFile(item) {
				if (item.isDir || item.fileType !== 'regular') return // Only allow viewing regular files
				this.loading = true
				this.status = `Reading file ${item.name}...`
				this.error = null
				this.currentItemName = item.name
				try {
					const fullPath = path.posix.join(this.currentPath, item.name)
					this.viewContent = await readFileContent(this.currentDev, fullPath)
					this.showViewModal = true
					this.status = `Viewing file ${item.name}`
				} catch (e) {
					this.error = `Failed to read file: ${e.message}`
					// Try to show partial content if available in error? Maybe too complex.
					this.viewContent = `Error reading file:\n\n${e.message}`
					this.showViewModal = true // Show error in modal
					console.error(e)
					this.status = `Error reading file ${item.name}`
				} finally {
					this.loading = false
				}
			},
			async createNewDirectory() {
				this.newDirModalVisible = true
				this.newDirName = ''
			},
			async confirmNewDirectory() {
				const newDirName = this.newDirName
				if (!newDirName || !newDirName.trim()) {
					this.newDirModalVisible = false
					return
				}
				if (newDirName.includes('/')) {
					this.newDirModalError = "Directory name cannot contain '/'"
					return
				}
				this.newDirModalVisible = false
				this.loading = true
				this.status = `Creating directory ${newDirName}...`
				this.error = null
				try {
					const newDirPath = path.posix.join(this.currentPath, newDirName.trim())
					await createDirectory(this.currentDev, newDirPath)
					this.status = `Directory ${newDirName} created.`
					await this.openDir(this.currentPath)
				} catch (e) {
					this.error = `Failed to create directory: ${e.message}`
					console.error(e)
					this.status = `Error creating directory ${newDirName}`
				}
			},
			cancelNewDirectory() {
				this.newDirModalVisible = false
			},
			async deleteSelectedItem(item) {
				const itemType = item.isDir ? 'directory' : 'file'
				const confirmMsg = `Are you sure you want to permanently delete the ${itemType} "${item.name}"?`
				if (!confirm(confirmMsg)) {
					return // User cancelled
				}

				this.loading = true
				this.status = `Deleting ${itemType} ${item.name}...`
				this.error = null
				try {
					const fullPath = path.posix.join(this.currentPath, item.name)
					if (item.isDir) {
						// Recursively delete directory contents first to emulate "rm -r"
						await this.removeDirectoryRecursive(this.currentDev, fullPath)
						await deleteItem(this.currentDev, fullPath, true)
					} else {
						await deleteItem(this.currentDev, fullPath, false)
					}
					this.status = `${itemType.charAt(0).toUpperCase() + itemType.slice(1)} ${item.name} deleted.`
					// Refresh current directory view
					await this.openDir(this.currentPath)
				} catch (e) {
					this.error = `Failed to delete ${itemType}: ${e.message}`
					console.error(e)
					this.status = `Error deleting ${itemType} ${item.name}`
					// Don't need finally loading=false here because openDir will handle it
				}
				// No finally needed as openDir sets loading state
			},
			// Recursively delete a directory and all its children
			async removeDirectoryRecursive(device, dirPath) {
				try {
					const entries = await listDir(device, dirPath)
					for (const entry of entries) {
						const childPath = path.posix.join(dirPath, entry.name)
						if (entry.isDir) {
							await this.removeDirectoryRecursive(device, childPath)
							await deleteItem(device, childPath, true).catch(() => {})
						} else {
							await deleteItem(device, childPath, false).catch(() => {})
						}
					}
				} catch (err) {
					// Log but continue – we don't want one failure to stop the whole deletion
					console.warn(`Failed to recurse into ${dirPath}: ${err.message}`)
				}
			},
			closeInfoModal() {
				this.showInfoModal = false
				this.infoContent = ''
				this.currentItemName = ''
			},
			closeViewModal() {
				this.showViewModal = false
				this.viewContent = ''
				this.currentItemName = ''
			},
			onDragEnter() {
				this.dragCounter++
				this.dragOver = true
			},
			onDragOver() {
				// No-op, just needed for .prevent
			},
			onDragLeave() {
				this.dragCounter--
				if (this.dragCounter <= 0) {
					this.dragOver = false
					this.dragCounter = 0
				}
			},
			onDrop(event) {
				this.dragOver = false
				this.dragCounter = 0
				const files = event.dataTransfer.files
				this.uploadDroppedItems(files)
			},
			// Upload dropped files and directories to the current directory
			async uploadDroppedItems(files) {
				this.loading = true
				this.status = `Uploading ${files.length} item(s)...`
				this.error = null
				try {
					const { webUtils } = require('electron')
					for (const file of Array.from(files)) {
						const localPath = webUtils.getPathForFile(file)
						if (!localPath) {
							throw new Error(`Could not get path for dropped file: ${file.name}`)
						}
						const name = file.name || path.basename(localPath)
						const fsPath = path.posix.join(this.currentPath, name)
						
						// Check if this is a directory
						const stats = fs.statSync(localPath)
						if (stats.isDirectory()) {
							this.status = `Uploading directory ${name}...`
							await this.uploadDirectory(localPath, fsPath)
						} else {
							this.status = `Uploading file ${name}...`
							await debugUtils.runDebugFs(this.currentDev, `write ${JSON.stringify(localPath)} ${fsPath}`, { write: true })
						}
					}
					this.status = `Upload complete`
					await this.openDir(this.currentPath)
				} catch (e) {
					this.error = `Upload failed: ${e.message}`
					console.error(e)
				} finally {
					this.loading = false
				}
			},
			// Recursively upload a directory into the filesystem
			async uploadDirectory(localDir, fsDir) {
				this.status = `Creating directory ${path.basename(fsDir)}...`
				await debugUtils.runDebugFs(this.currentDev, `mkdir ${fsDir}`, { write: true })
				
				// Read directory contents and upload each item
				const entries = fs.readdirSync(localDir)
				for (const entry of entries) {
					const localEntry = path.join(localDir, entry)
					const fsEntry = path.posix.join(fsDir, entry)
					const stats = fs.statSync(localEntry)
					
					if (stats.isDirectory()) {
						await this.uploadDirectory(localEntry, fsEntry)
					} else if (stats.isFile()) {
						this.status = `Uploading file ${entry}...`
						await debugUtils.runDebugFs(this.currentDev, `write ${JSON.stringify(localEntry)} ${fsEntry}`, { write: true })
					}
				}
			},
			formatMode(modeStr) {
				// Expect octal permission bits as string (e.g., "100755" or "0755")
				if (!modeStr) return ''
				let permBits = parseInt(modeStr, 8) & 0o777 // keep lower 9 bits
				let res = ''
				for (let i = 2; i >= 0; i--) {
					const part = (permBits >> (i * 3)) & 0b111
					res += (part & 4 ? 'r' : '-')
					res += (part & 2 ? 'w' : '-')
					res += (part & 1 ? 'x' : '-')
				}
				return res
			},
			formatModified(ts) {
				if (ts == undefined) return ''
				// Create Dayjs object from the (now correct) local Unix timestamp
				const d = dayjs.unix(ts)
				const now = dayjs() // Current local time
				if (d.isSame(now, 'day')) {
					return `Today at ${d.format('h:mm A')}`
				}
				if (d.isSame(now.subtract(1, 'day'), 'day')) {
					return `Yesterday at ${d.format('h:mm A')}`
				}
				return d.format('D MMM YYYY [at] h:mm A')
			},
		},
		mounted() {
			// Initial setup: Find tools and start scanning
			this.status = "Initializing..."
			this.loading = true
			if (this.findTools()) {
				this.startAutoRescan()
			}
			// If findTools failed, it will have set loading=false and an error message.
		},
		beforeUnmount() {
			this.stopAutoRescan() // Clean up interval on component destruction
		}
	}).mount('#app');
</script>
</html>