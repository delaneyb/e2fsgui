<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<title>e2fsgui</title>
	<script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
	<style>
		body {
			margin: 0;
			display: flex;
			height: 100vh;
			font: 14px/1.4 -apple-system, Segoe UI, Roboto, sans-serif;
			color: #222;
		}

		#app {
			display: flex;
			flex: 1;
			flex-direction: column;
		}

		.container {
			display: flex;
			flex: 1;
			overflow: hidden;
		}

		#sidebar {
			width: 220px;
			border-right: 1px solid #ddd;
			overflow: auto;
			background: #fafafa;
		}

		#sidebar div {
			padding: 10px 12px;
			cursor: pointer;
			border-bottom: 1px solid #eee;
		}

		#sidebar div:hover {
			background: #f0f0f0;
		}

		#sidebar .active {
			background: #dbeaff;
			font-weight: 600;
		}

		#main {
			flex: 1;
			display: flex;
			flex-direction: column;
			overflow: auto;
		}

		#crumb {
			position: sticky;
			top: 0;
			padding: 8px 12px;
			border-bottom: 1px solid #ddd;
			background: #f7f7f7;
			font-size: 13px;
			color: #666;
			user-select: none;
			z-index: 2;
			display: flex;
			align-items: center;
			flex-wrap: wrap;
		}

		table {
			border-collapse: collapse;
			width: 100%;
		}

		tr {
			border-bottom: 1px solid #eee;
		}

		td,
		th {
			padding: 6px 8px;
			text-align: left;
		}

		tr:hover {
			background: #f9f9f9;
		}

		/* Modern button style */
		button {
			padding: 6px 12px;
			border: none;
			border-radius: 4px;
			background-color: #f2f2f2;
			color: #333;
			cursor: pointer;
			transition: background-color 0.2s;
		}
		button:hover:not(:disabled) {
			background-color: #e0e0e0;
		}
		button:disabled {
			opacity: 0.6;
			cursor: not-allowed;
		}

		/* Actions row buttons */
		.actions-row button {
			margin: 0;
		}

		/* Icon-only action buttons - square, centered */
		.action-icon-only {
			width: 36px;
			height: 36px;
			display: flex;
			align-items: center;
			justify-content: center;
			border: none;
			border-radius: 4px;
			background-color: #f2f2f2;
			cursor: pointer;
			transition: background-color 0.2s;
			padding: 0;
		}
		.action-icon-only:hover:not(:disabled) {
			background-color: #e0e0e0;
		}

		.status-bar {
			padding: 8px 12px;
			background: #f0f0f0;
			border-top: 1px solid #ddd;
			font-size: 13px;
			color: #666;
			white-space: pre-wrap;
		}

		.error {
			color: #d32f2f;
			background: #ffebee;
			padding: 8px 12px;
			white-space: pre-wrap;
			overflow-wrap: break-word;
		}

		.loading-overlay {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(255, 255, 255, 0.7);
			display: flex;
			align-items: center;
			justify-content: center;
			z-index: 10;
		}

		.loader {
			border: 3px solid #f3f3f3;
			border-top: 3px solid #3498db;
			border-radius: 50%;
			width: 20px;
			height: 20px;
			animation: spin 1s linear infinite;
			margin-right: 10px;
		}

		@keyframes spin {
			0% {
				transform: rotate(0deg);
			}

			100% {
				transform: rotate(360deg);
			}
		}

		[v-cloak] {
			display: none;
		}

		.crumb-sep {
			margin: 0 4px;
			color: #666;
		}

		.crumb-segment {
			display: inline-block;
			background: gainsboro;
			border-radius: 4px;
			padding: 2px 6px;
			margin: 0 2px;
			cursor: pointer;
		}

		.crumb-segment.current {
			background: #ccc;
			cursor: default;
		}

		.crumb-segment a {
			color: inherit;
			text-decoration: none;
		}

		table thead th {
			position: sticky;
			top: 40px;
			background: #fafafa;
			z-index: 1;
		}

		th:first-child,
		td:first-child {
			width: 32px;
			text-align: center;
		}

		th:nth-child(2),
		td:nth-child(2) {
			min-width: 150px;
		}

		th:nth-child(3),
		td:nth-child(3) {
			min-width: 80px;
		}

		th:nth-child(4),
		td:nth-child(4) {
			min-width: 70px;
		}

		th:nth-child(5),
		td:nth-child(5) {
			min-width: 50px;
			text-align: right;
		}

		th:nth-child(6),
		td:nth-child(6) {
			min-width: 50px;
			text-align: right;
		}

		th:nth-child(7),
		td:nth-child(7) {
			min-width: 230px;
			text-align: left;
		}

		button:first-child {
			margin-left: 0;
		}

		.actions-row {
			display: flex;
			gap: 8px;
			align-items: center;
		}

		.action-icon-only[style*="color:red"] {
			color: #d32f2f;
		}
	</style>
</head>

<body>
	<div id="app" v-cloak>
		<div class="container">
			<div id="sidebar">
				<div v-for="d in disks" :key="d.id" :class="{active: currentDev===d.id}" @click="openDisk(d)">{{ d.name }} ({{ d.size }})</div>
				<div v-if="disks.length === 0 && !loading" style="color:#666;cursor:default;font-style:italic">No Linux partitions found</div>
			</div>
			<div id="main">
				<div id="crumb">
					<template v-if="currentDev">
						<span v-for="(seg, idx) in crumbSegments" :key="idx">
							<span v-if="idx > 0" class="crumb-sep">/</span>
							<span :class="['crumb-segment', { current: seg.path === currentPath } ]">
								<template v-if="seg.path === currentPath">{{ seg.name }}</template>
								<a v-else href="#" @click.prevent="openDir(seg.path)">{{ seg.name }}</a>
							</span>
						</span>
						<!-- Add New Folder Button -->
						<button @click="createNewDirectory" style="margin-left: 15px;" title="Create New Folder">+</button>
					</template>
					<template v-else>Select a Linux disk…</template>
				</div>
				<div v-if="error" class="error">{{ error }}</div>
				<table v-if="currentDev">
					<thead>
						<tr>
							<th></th>
							<th @click="sortBy('name')" style="cursor:pointer">
								Name <span v-if="sortKey==='name'">{{ sortAsc ? '▲' : '▼' }}</span>
							</th>
							<th @click="sortBy('size')" style="cursor:pointer">
								Size <span v-if="sortKey==='size'">{{ sortAsc ? '▲' : '▼' }}</span>
							</th>
							<th @click="sortBy('mode')" style="cursor:pointer">
								Mode <span v-if="sortKey==='mode'">{{ sortAsc ? '▲' : '▼' }}</span>
							</th>
							<th @click="sortBy('uid')" style="cursor:pointer">
								UID <span v-if="sortKey==='uid'">{{ sortAsc ? '▲' : '▼' }}</span>
							</th>
							<th @click="sortBy('gid')" style="cursor:pointer">
								GID <span v-if="sortKey==='gid'">{{ sortAsc ? '▲' : '▼' }}</span>
							</th>
							<th style="text-align:left;">Actions</th>
						</tr>
					</thead>
					<tbody>
						<tr v-if="currentPath!=='/'" @click="upOne" style="cursor:pointer">
							<td><i class="fas fa-arrow-up"></i></td>
							<td colspan="3">..</td>
							<td colspan="3"></td>
						</tr>
						<tr v-for="r in sortedRows" :key="r.name" @click="r.isDir ? openDir(r.name) : null" :style="r.isDir ? 'cursor:pointer' : ''">
							<td>
								<i v-if="r.fileType === 'directory'" class="fa-solid fa-folder"></i>
								<i v-else-if="r.fileType === 'symlink'" class="fa-solid fa-link"></i>
								<i v-else-if="r.fileType === 'block'" class="fa-solid fa-hard-drive"></i>
								<i v-else-if="r.fileType === 'character'" class="fa-solid fa-terminal"></i>
								<i v-else-if="r.fileType === 'fifo'" class="fa-solid fa-pipe"></i>
								<i v-else-if="r.fileType === 'socket'" class="fa-solid fa-plug"></i>
								<i v-else class="fa-solid fa-file"></i>
							</td>
							<td>{{ r.name }}</td>
							<td>{{ r.isDir ? '' : r.size }}</td>
							<td>{{ r.mode }}</td>
							<td style="text-align: right;">{{ r.uid }}</td>
							<td style="text-align: right;">{{ r.gid }}</td>
							<td>
								<div class="actions-row">
									<button v-if="!r.isDir && r.fileType === 'regular'" @click.stop="viewFile(r)" title="View File Content"><i class="fa-solid fa-eye"></i> View</button>
									<button v-if="r.fileType === 'directory'" @click.stop="saveDirectory(r)" :disabled="!!r.saveStatus && r.saveStatus !== '✔ Saved'"><i class="fa-solid fa-save"></i> {{ r.saveStatus || (r.saved ? 'Saved' : 'Save') }}</button>
									<button v-else @click.stop="saveFile(r)" :disabled="!!r.saveStatus && r.saveStatus !== '✔ Saved'"><i class="fa-solid fa-save"></i> {{ r.saveStatus || (r.saved ? 'Saved' : 'Save') }}</button>
									<button @click.stop="showInfo(r)" title="Show Info" class="action-icon-only"><i class="fa-solid fa-circle-info"></i></button>
									<button @click.stop="deleteSelectedItem(r)" title="Delete Item" class="action-icon-only" style="color:red;"><i class="fa-solid fa-trash"></i></button>
								</div>
							</td>
						</tr>
						<tr v-if="rows.length === 0 && !loading && !error">
							<td colspan="7" style="text-align:center;padding:20px;color:#666">
								This directory is empty
							</td>
						</tr>
					</tbody>
				</table>
			</div>
		</div>

		<div class="status-bar">{{ status }}</div>

		<div v-if="loading" class="loading-overlay">
			<div class="loader"></div>
			<div>{{ status }}</div>
		</div>

		<!-- Info Modal -->
		<div v-if="showInfoModal" class="loading-overlay" @click.self="closeInfoModal" style="background: rgba(0,0,0,0.5); z-index: 20;">
			<div style="background: white; padding: 20px; border-radius: 5px; max-width: 80%; max-height: 80%; display: flex; flex-direction: column; overflow: hidden;">
				<h3>Info: {{ currentItemName }}</h3>
				<pre style="flex: 1; overflow: auto; white-space: pre-wrap; word-wrap: break-word; background: #f8f8f8; border: 1px solid #eee; padding: 10px; margin: 10px 0; min-height: 0;">{{ infoContent }}</pre>
				<button @click="closeInfoModal" style="align-self: flex-end; margin-top: 10px;">Close</button>
			</div>
		</div>

		<!-- View File Modal -->
		<div v-if="showViewModal" class="loading-overlay" @click.self="closeViewModal" style="background: rgba(0,0,0,0.5); z-index: 20;">
			<div style="background: white; padding: 20px; border-radius: 5px; max-width: 90%; max-height: 90%; display: flex; flex-direction: column; overflow: hidden;">
				<h3>View: {{ currentItemName }}</h3>
				<pre style="flex: 1; overflow: auto; white-space: pre-wrap; word-wrap: break-word; background: #f8f8f8; border: 1px solid #eee; padding: 10px; min-height: 0;">{{ viewContent }}</pre>
				<button @click="closeViewModal" style="align-self: flex-end; margin-top: 10px;">Close</button>
			</div>
		</div>
	</div>

	<script>
		const { execSync, execFile } = require('child_process')
		const path = require('path')
		const os = require('os')
		const fs = require('fs')
		const debugUtils = require('./debugfs-utils')

		// Find Homebrew installation path and e2fsprogs binaries
		function findHomebrewPath() {
			try {
				// Try to get the Homebrew prefix
				const brewPrefix = execSync('brew --prefix').toString().trim()
				return brewPrefix
			} catch (e) {
				console.error("Error finding Homebrew:", e)
				// Fallbacks for common Homebrew locations
				if (fs.existsSync('/opt/homebrew')) {
					return '/opt/homebrew' // M1/M2 Mac location
				} else if (fs.existsSync('/usr/local/Homebrew')) {
					return '/usr/local' // Intel Mac location
				}
				return null
			}
		}

		// Get full path to a Homebrew-installed program
		function getBrewBinPath(program) {
			const brewPath = findHomebrewPath()
			if (!brewPath) return null

			// Check e2fsprogs paths - binaries might be in bin/ or sbin/
			const e2fsprogsPrefix = path.join(brewPath, 'opt', 'e2fsprogs')

			const possiblePaths = [
				path.join(e2fsprogsPrefix, 'sbin', program),
				path.join(e2fsprogsPrefix, 'bin', program),
				path.join(brewPath, 'sbin', program),
				path.join(brewPath, 'bin', program),
			]

			for (const binPath of possiblePaths) {
				if (fs.existsSync(binPath)) {
					return binPath
				}
			}

			return null
		}

		function plistXmlToJson(xmlStr) {
			const buf = execSync('plutil -convert json -o - -', { input: xmlStr })
			return JSON.parse(buf.toString())
		}

		function listLinuxDisks() {
			const xml = execSync('diskutil list -plist').toString()
			const data = plistXmlToJson(xml)
			if (!data.AllDisksAndPartitions) return []
			return data.AllDisksAndPartitions.flatMap(d => {
				// Make sure this disk has partitions
				if (!d.Partitions) return []

				// Filter and map partitions with Linux content
				return d.Partitions
					.filter(p => /Linux/i.test(p.Content || ''))
					.map(p => ({
						id: p.DeviceIdentifier,
						name: p.VolumeName || p.DeviceIdentifier,
						size: p.Size ? formatSize(p.Size) : 'Unknown',
						sizeBytes: p.Size || 0
					}))
			})
		}

		// Helper function to format bytes to readable size
		function formatSize(bytes) {
			if (bytes === 0) return '0 B'
			const sizes = ['B', 'KB', 'MB', 'GB', 'TB']
			const i = Math.floor(Math.log(bytes) / Math.log(1024))
			return (bytes / Math.pow(1024, i)).toFixed(1) + ' ' + sizes[i]
		}

		function listDir(device, dirPath) {
			return debugUtils.runDebugFs(device, `ls -p ${dirPath}`)
				.then(({ stdout }) => {
					const rows = []
					const outputLines = stdout.split('\n').filter(line =>
						line.trim() !== '' &&
						!line.startsWith('debugfs') &&
						!line.includes('1-Jan-2025')
					)
					outputLines.forEach(line => {
						const match = line.match(/^\s*\/(\d+)\/(\d+)\/(\d+)\/(\d+)\/(.+?)(\/\/|\/(\d+)\/)$/)
						if (match) {
							const [ , inode, mode, uid, gid, rawName, slashType, sizeStr ] = match
							let name = rawName.trim().replace(/\\\//g, '/')
							if (name === '.' || name === '..') return
							const isDir = slashType === '//'
							const rawSize = isDir ? 0 : parseInt(sizeStr || '0', 10)
							const size = isDir ? '' : formatSize(rawSize)
							const modeNum = parseInt(mode, 8)
							const fileType = getFileType(modeNum)
							rows.push({ name, isDir, size, inode, mode, uid, gid, rawSize, fileType })
						} else {
							console.warn('Failed to parse debugfs line:', line)
						}
					})
					return rows
				})
		}

		// Helper function to determine file type from mode bits
		function getFileType(modeNum) {
			// File type constants (octal)
			const S_IFMT = 0o170000;  // bit mask for the file type bit field
			const S_IFSOCK = 0o140000; // socket
			const S_IFLNK = 0o120000;  // symbolic link
			const S_IFREG = 0o100000;  // regular file
			const S_IFBLK = 0o060000;  // block device
			const S_IFDIR = 0o040000;  // directory
			const S_IFCHR = 0o020000;  // character device
			const S_IFIFO = 0o010000;  // FIFO/pipe

			const type = modeNum & S_IFMT;

			if (type === S_IFDIR) return 'directory';
			if (type === S_IFREG) return 'regular';
			if (type === S_IFLNK) return 'symlink';
			if (type === S_IFBLK) return 'block';
			if (type === S_IFCHR) return 'character';
			if (type === S_IFIFO) return 'fifo';
			if (type === S_IFSOCK) return 'socket';
			return 'unknown';
		}

		function copyFile(device, srcPath, destDir) {
			return new Promise((resolve, reject) => {
				const dest = path.join(destDir, path.basename(srcPath))
				debugUtils.runDebugFs(device, `dump -p ${srcPath} ${dest}`)
					.then(() => {
						const sudoUid = process.env.SUDO_UID && parseInt(process.env.SUDO_UID, 10)
						const sudoGid = process.env.SUDO_GID && parseInt(process.env.SUDO_GID, 10)
						if (sudoUid && sudoGid && !isNaN(sudoUid) && !isNaN(sudoGid)) {
							try { fs.chownSync(dest, sudoUid, sudoGid) } catch (e) { console.warn(`Failed to chown ${dest}: ${e.message}`) }
						}
						resolve(dest)
					})
					.catch(err => reject(new Error(`Failed to copy file: ${err.message}`)))
			})
		}

		function copyDirectory(device, srcPath, destDir) {
			return debugUtils.runDebugFs(device, `rdump ${srcPath} ${destDir}`)
				.then(() => {
					const sudoUid = process.env.SUDO_UID && parseInt(process.env.SUDO_UID, 10)
					const sudoGid = process.env.SUDO_GID && parseInt(process.env.SUDO_GID, 10)
					if (sudoUid && sudoGid && !isNaN(sudoUid) && !isNaN(sudoGid)) {
						try {
							fs.chownSync(destDir, sudoUid, sudoGid)
							execSync(`find ${JSON.stringify(destDir)} -exec chown ${sudoUid}:${sudoGid} {} +`)
						} catch (e) {
							console.warn(`Failed to recursively chown ${destDir}: ${e.message}`)
						}
					}
					return destDir
				})
				.catch(err => { throw new Error(`Failed to copy directory: ${err.message}`) })
		}

		function getInodeInfo(device, itemPath) {
			return debugUtils.runDebugFs(device, `stat ${itemPath}`)
				.then(({ stdout, stderr }) => (stdout.trim() || stderr.trim()))
		}

		function readFileContent(device, filePath) {
			return debugUtils.runDebugFs(device, `cat ${filePath}`, { maxBuffer: 1024 * 1024 * 5 })
				.then(({ stdout, stderr }) => {
					if (stderr && stderr.includes('Cannot read block') && stdout) {
						console.warn(`readFileContent: Partial read or error for ${filePath}: ${stderr}`)
						return stdout + "\n\n[Warning: Error during read - content might be incomplete or corrupted]"
					}
					return stdout
				})
		}

		function createDirectory(device, newDirPath) {
			return debugUtils.runDebugFs(device, `mkdir ${newDirPath}`, { write: true }).then(() => {})
		}

		function deleteItem(device, itemPath, isDir) {
			const cmd = isDir ? `rmdir ${itemPath}` : `rm ${itemPath}`
			return debugUtils.runDebugFs(device, cmd, { write: true })
				.catch(err => {
					if (err.message && err.message.includes('Directory not empty')) {
						throw new Error(`Directory not empty: ${itemPath}`)
					}
					throw new Error(`Failed to delete ${isDir ? 'directory' : 'file'}: ${err.message}`)
				})
		}

		const { createApp } = Vue
		createApp({
			data() {
				return {
					disks: [],
					currentDev: null,
					currentPath: '/',
					rows: [],
					lastDestDir: path.join(os.homedir(), 'Downloads'),
					loading: true,
					status: 'Looking for Linux partitions...',
					error: null,
					debugfsPath: null,
					e2cpPath: null,
					scanInterval: null,
					sortKey: 'name',
					sortAsc: true,
					// New state for modals
					showInfoModal: false,
					infoContent: '',
					showViewModal: false,
					viewContent: '',
					currentItemName: '', // For modal titles
				}
			},
			computed: {
				crumbSegments() {
					if (!this.currentDev) return []
					const parts = this.currentPath.split('/').filter(Boolean)
					const segments = []
					// first segment shows the disk identifier
					segments.push({ name: this.currentDev, path: '/' })
					let accum = '/'
					parts.forEach(part => {
						accum = path.posix.join(accum, part) // Use path.posix.join for reliability
						segments.push({ name: part, path: accum })
					})
					return segments
				},
				sortedRows() {
					const sorted = [...this.rows]
					sorted.sort((a, b) => {
						// Always sort directories first
						if (a.isDir !== b.isDir) {
							return a.isDir ? -1 : 1
						}
						let result
						if (this.sortKey === 'name') {
							result = a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' })
						} else if (this.sortKey === 'size') {
							result = a.rawSize - b.rawSize
						} else if (this.sortKey === 'mode') {
							// Simple string comparison for octal mode
							result = (a.mode || '').localeCompare(b.mode || '')
						} else if (this.sortKey === 'uid') {
							result = parseInt(a.uid || '0') - parseInt(b.uid || '0')
						} else if (this.sortKey === 'gid') {
							result = parseInt(a.gid || '0') - parseInt(b.gid || '0')
						} else {
							result = 0 // Should not happen
						}
						return this.sortAsc ? result : -result
					})
					return sorted
				},
			},
			methods: {
				findTools() {
					this.loading = true
					this.status = "Locating e2fsprogs binaries..."

					this.debugfsPath = debugUtils.getBrewBinPath('debugfs')
					this.e2cpPath = debugUtils.getBrewBinPath('e2cp')

					if (!this.debugfsPath) {
						this.error = `Cannot find 'debugfs'. Please install e2fsprogs with: brew install e2fsprogs`
						this.loading = false
						return false
					}

					this.status = `Found debugfs at ${this.debugfsPath}`
					this.status += "\nReady (running as root)"

					return true
				},
				refreshDisks(showLoading = true) {
					if (showLoading) {
						this.loading = true
					}
					this.error = null

					if (showLoading) {
						this.status = "Looking for Linux partitions..."
					}

					if (!this.findTools()) {
						return
					}

					try {
						this.disks = listLinuxDisks()

						if (this.disks.length === 0) {
							// If no disks found, start auto-rescanning
							this.startAutoRescan()
							// We're still loading (scanning) in this case
							this.loading = true
						} else {
							// If disks found, stop auto-rescanning and hide loading indicator
							this.stopAutoRescan()
							this.status = `Found ${this.disks.length} Linux partition(s). Select one to browse.`
							this.loading = false
							// Auto-select first disk if none selected
							if (!this.currentDev) {
								this.openDisk(this.disks[0])
							}
						}
					} catch (e) {
						this.error = `Error detecting Linux partitions: ${e.message}`
						console.error(e)
						this.loading = false
						this.stopAutoRescan() // Stop scanning on error
					}
				},
				openDisk(d) {
					this.currentDev = d.id
					this.openDir('/')
				},
				async openDir(dir) {
					this.rows = []
					this.loading = true
					this.error = null
					// compute new absolute path for the directory
					const oldPath = this.currentPath || '/'
					const newPath = dir.startsWith('/')
						? dir
						: (oldPath === '/' ? `/${dir}` : `${oldPath}/${dir}`)
					this.currentPath = newPath
					this.status = `Reading directory ${newPath}...`

					try {
						this.rows = await listDir(this.currentDev, newPath)
						this.status = `Browsing ${this.currentDev}${newPath} - ${this.rows.length} entries`
					} catch (e) {
						this.error = `Failed to list directory: ${e.message}`
						console.error(e)
					} finally {
						this.loading = false
					}
				},
				upOne() {
					if (this.currentPath === '/' || !this.currentPath) return
					const parent = path.posix.dirname(this.currentPath)
					this.openDir(parent)
				},
				async saveFile(row) {
					const originalText = row.saved ? '✔ Saved' : 'Save'
					row.saveStatus = 'Copying...'
					row.error = null // Clear previous error for this item

					try {
						const fullSrcPath = path.posix.join(this.currentPath, row.name)
						const destPath = await copyFile(this.currentDev, fullSrcPath, this.lastDestDir)
						row.saved = true
						row.saveStatus = '✔ Saved'
						this.status = `File saved to ${destPath}`
					} catch (e) {
						row.saveStatus = '❌ Failed'
						row.error = `Copy failed: ${e.message}` // Store error on the row? Or use global error?
						this.error = `Copy failed for ${row.name}: ${e.message}` // Show globally too
						console.error(e)

						// Reset status after 5 seconds
						setTimeout(() => {
							if (row.saveStatus === '❌ Failed') { // Only reset if still failed
								row.saveStatus = originalText
							}
						}, 5000)
					}
				},
				// save an entire directory recursively
				async saveDirectory(row) {
					const originalText = row.saved ? '✔ Saved' : 'Save'
					row.saveStatus = 'Copying...'
					row.error = null

					try {
						const fullSrcPath = path.posix.join(this.currentPath, row.name)
						const destPath = await copyDirectory(this.currentDev, fullSrcPath, this.lastDestDir)
						row.saved = true // Should we mark directory as saved? Maybe less useful.
						row.saveStatus = '✔ Saved'
						this.status = `Directory saved to ${destPath}` // Use actual returned path
					} catch (e) {
						row.saveStatus = '❌ Failed'
						row.error = `Copy failed: ${e.message}`
						this.error = `Copy failed for directory ${row.name}: ${e.message}`
						console.error(e)
						setTimeout(() => {
							if (row.saveStatus === '❌ Failed') {
								row.saveStatus = originalText
							}
						}, 5000)
					}
				},
				startAutoRescan() {
					this.stopAutoRescan() // Ensure no duplicate intervals

					this.status = "Scanning for Linux partitions (plug in drive if needed)..."
					this.loading = true

					// Initial scan immediately
					this.scanDisksInBackground()

					// Start scanning every 2 seconds (1s might be too frequent)
					this.scanInterval = setInterval(this.scanDisksInBackground, 2000)
				},
				scanDisksInBackground() {
					// Don't show loading indicator during background scans unless it's already loading
					// Don't show status updates unless disks are found or an error occurs initially

					try {
						const currentDisks = listLinuxDisks()
						// Check if the list of disks actually changed (simple length check for now)
						// A more robust check would compare disk IDs if needed
						if (currentDisks.length > 0 && this.disks.length === 0) {
							this.disks = currentDisks
							this.stopAutoRescan()
							this.status = `Found ${this.disks.length} Linux partition(s). Select one to browse.`
							this.loading = false // Hide loading indicator now
						} else if (currentDisks.length === 0 && this.disks.length > 0) {
							// Disks were removed, reset state
							this.disks = []
							this.currentDev = null
							this.currentPath = '/'
							this.rows = []
							this.error = null
							// Restart scanning
							this.startAutoRescan()
						}
						// If list is unchanged (and >0), or still 0, do nothing visually
					} catch (e) {
						// Only show error if it's the *first* scan attempt or if loading is active
						if (this.loading) {
							this.error = `Error during disk scan: ${e.message}`
							console.error("Error during auto-scan:", e)
							this.loading = false // Stop showing loading on error
						} else {
							// Log subsequent errors quietly
							console.warn("Non-critical error during background disk scan:", e.message)
						}
						// Consider stopping scan on persistent errors?
						// this.stopAutoRescan()
					}
				},
				stopAutoRescan() {
					if (this.scanInterval) {
						clearInterval(this.scanInterval)
						this.scanInterval = null
					}
				},
				sortBy(key) {
					if (this.sortKey === key) {
						this.sortAsc = !this.sortAsc
					} else {
						this.sortKey = key
						this.sortAsc = true // Default to ascending when changing column
					}
				},
				// ---- New Methods ----
				async showInfo(item) {
					this.loading = true
					this.status = `Getting info for ${item.name}...`
					this.error = null
					this.currentItemName = item.name
					try {
						const fullPath = path.posix.join(this.currentPath, item.name)
						this.infoContent = await getInodeInfo(this.currentDev, fullPath)
						this.showInfoModal = true
						this.status = `Showing info for ${item.name}`
					} catch (e) {
						this.error = `Failed to get info: ${e.message}`
						console.error(e)
						this.status = `Error getting info for ${item.name}`
					} finally {
						this.loading = false
					}
				},
				async viewFile(item) {
					if (item.isDir || item.fileType !== 'regular') return // Only allow viewing regular files
					this.loading = true
					this.status = `Reading file ${item.name}...`
					this.error = null
					this.currentItemName = item.name
					try {
						const fullPath = path.posix.join(this.currentPath, item.name)
						this.viewContent = await readFileContent(this.currentDev, fullPath)
						this.showViewModal = true
						this.status = `Viewing file ${item.name}`
					} catch (e) {
						this.error = `Failed to read file: ${e.message}`
						// Try to show partial content if available in error? Maybe too complex.
						this.viewContent = `Error reading file:\n\n${e.message}`
						this.showViewModal = true // Show error in modal
						console.error(e)
						this.status = `Error reading file ${item.name}`
					} finally {
						this.loading = false
					}
				},
				async createNewDirectory() {
					const newDirName = prompt("Enter name for new directory:")
					if (!newDirName || !newDirName.trim()) {
						return // User cancelled or entered empty name
					}

					// Basic validation for invalid characters (e.g., '/')
					if (newDirName.includes('/')) {
						alert("Directory name cannot contain '/'")
						return
					}

					this.loading = true
					this.status = `Creating directory ${newDirName}...`
					this.error = null
					try {
						const newDirPath = path.posix.join(this.currentPath, newDirName.trim())
						await createDirectory(this.currentDev, newDirPath)
						this.status = `Directory ${newDirName} created.`
						// Refresh current directory view
						await this.openDir(this.currentPath)
					} catch (e) {
						this.error = `Failed to create directory: ${e.message}`
						console.error(e)
						this.status = `Error creating directory ${newDirName}`
						// Don't need finally loading=false here because openDir will handle it
					}
					// No finally needed as openDir sets loading state
				},
				async deleteSelectedItem(item) {
					const itemType = item.isDir ? 'directory' : 'file'
					const confirmMsg = `Are you sure you want to permanently delete the ${itemType} "${item.name}"?`
					if (!confirm(confirmMsg)) {
						return // User cancelled
					}

					this.loading = true
					this.status = `Deleting ${itemType} ${item.name}...`
					this.error = null
					try {
						const fullPath = path.posix.join(this.currentPath, item.name)
						await deleteItem(this.currentDev, fullPath, item.isDir)
						this.status = `${itemType.charAt(0).toUpperCase() + itemType.slice(1)} ${item.name} deleted.`
						// Refresh current directory view
						await this.openDir(this.currentPath)
					} catch (e) {
						this.error = `Failed to delete ${itemType}: ${e.message}`
						console.error(e)
						this.status = `Error deleting ${itemType} ${item.name}`
						// Don't need finally loading=false here because openDir will handle it
					}
					// No finally needed as openDir sets loading state
				},
				closeInfoModal() {
					this.showInfoModal = false
					this.infoContent = ''
					this.currentItemName = ''
				},
				closeViewModal() {
					this.showViewModal = false
					this.viewContent = ''
					this.currentItemName = ''
				},
			},
			mounted() {
				// Initial setup: Find tools and start scanning
				this.status = "Initializing..."
				this.loading = true
				if (this.findTools()) {
					this.startAutoRescan()
				}
				// If findTools failed, it will have set loading=false and an error message.
			},
			beforeUnmount() {
				this.stopAutoRescan() // Clean up interval on component destruction
			}
		}).mount('#app');
	</script>
</body>

</html>